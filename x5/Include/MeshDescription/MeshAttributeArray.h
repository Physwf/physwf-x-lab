#pragma once

#include <vector>
#include <map>
#include <string>
#include <tuple>

using AttributeTypes = std::tuple
<
	FVector4,
	FVector,
	FVector2D,
	float,
	int,
	bool,
	std::string
>;

template <typename ElementType>
class TMeshAttributeArrayBase
{
public:
protected:

	friend class UMeshDescription;

	void Insert(const int32 Index, const ElementType& Default)
	{
		if (Index >= (int32)Container.size())
		{
			Container.resize(Index, ElementType(Default));
		}
	}

	void Initialize(const int32 ElementCount, const ElementType& Default)
	{
		Container.clear();
		Insert(ElementCount - 1, Default);
	}
protected:
	std::vector<ElementType> Container;
};

template <typename AttributeType, typename ElementIDType>
class TAttributeIndicesArray;

template <typename ElementType, typename ElementIDType>
class TMeshAttributeArray : private TMeshAttributeArrayBase<ElementType>
{
	using TMeshAttributeArrayBase<ElementType>::Container;
public:

	/** Element accessors */
	inline const ElementType& operator[](const ElementIDType ElementID) const { return Container[ElementID.GetValue()]; }
	inline ElementType& operator[](const ElementIDType ElementID) { return Container[ElementID.GetValue()]; }

	/** Return size of container */
	inline int32 Num() const { return Container.Num(); }

	/** Return base of data */
	inline const ElementType* GetData() const { return Container.data(); }

protected:
	friend class TAttributeIndicesArray <ElementType, ElementIDType>;
};

enum class EMeshAttributeFlags : uint32
{
	None = 0,
	Lerpable = (1 << 0),
	AutoGenerated = (1 << 1),
	Mergeable = (1 << 2)
};

template <typename T, typename U>
class TAttributeIndicesArray
{
public:
	using AttributeType = T;
	using ElementIDType = U;

	/** Default constructor - required so that it builds correctly */
	TAttributeIndicesArray() = default;

	/** Constructor */
	TAttributeIndicesArray(const int32 NumberOfIndices, const AttributeType& InDefaultValue, const EMeshAttributeFlags InFlags, const int32 InNumberOfElements)
		: NumElements(InNumberOfElements),
		DefaultValue(InDefaultValue),
		Flags(InFlags)
	{
		SetNumIndices(NumberOfIndices);
	}

	inline void Insert(const ElementIDType ElementID)
	{
		for (TMeshAttributeArray<AttributeType, ElementIDType>& ArrayForIndex : ArrayForIndices)
		{
			ArrayForIndex.Insert(ElementID, DefaultValue);
		}

		NumElements = FMath::Max(NumElements, ElementID.GetValue() + 1);
	}

	/** Remove the element at the given index, replacing it with a default value */
	inline void Remove(const ElementIDType ElementID)
	{
		for (TMeshAttributeArray<AttributeType, ElementIDType>& ArrayForIndex : ArrayForIndices)
		{
			ArrayForIndex[ElementID] = DefaultValue;
		}
	}

	/** Return the TMeshAttributeArray corresponding to the given attribute index */
	inline const TMeshAttributeArray<AttributeType, ElementIDType>& GetArrayForIndex(const int32 Index) const { return ArrayForIndices[Index]; }
	inline TMeshAttributeArray<AttributeType, ElementIDType>& GetArrayForIndex(const int32 Index) { return ArrayForIndices[Index]; }

	/** Return flags for this attribute type */
	inline EMeshAttributeFlags GetFlags() const { return Flags; }

	/** Return default value for this attribute type */
	inline AttributeType GetDefaultValue() const { return DefaultValue; }

	/** Return number of indices this attribute has */
	inline int32 GetNumIndices() const { return ArrayForIndices.Num(); }

	/** Return number of elements each attribute index has */
	inline int32 GetNumElements() const { return NumElements; }

	void SetNumIndices(const int32 NumIndices)
	{
		//check(NumIndices > 0);
		const int32 OriginalNumIndices = ArrayForIndices.size();
		ArrayForIndices.resize(NumIndices);

		// If we have added new indices, ensure they are filled out with the correct number of elements
		for (int32 Index = OriginalNumIndices; Index < NumIndices; ++Index)
		{
			ArrayForIndices[Index].Initialize(NumElements, DefaultValue);
		}
	}
private:
	/** Number of elements in each index */
	int32 NumElements;

	/** An array of MeshAttributeArrays, one per attribute index */
	std::vector<TMeshAttributeArray<AttributeType, ElementIDType>> ArrayForIndices;

	/** The default value for an attribute of this name */
	AttributeType DefaultValue;

	/** Implementation-defined attribute name flags */
	EMeshAttributeFlags Flags;
};

template <typename T, typename U>
class TAttributesMap
{
public:
	using AttributeType = T;
	using ElementIDType = U;
	using AttributeIndicesArrayType = TAttributeIndicesArray<AttributeType, ElementIDType>;
	using MapType = std::map<std::string, AttributeIndicesArrayType>;

	inline TAttributesMap()
		: NumElements(0)
	{}

	inline void RegisterAttribute(const std::string& AttributeName, const int32 NumberOfIndices, const AttributeType& Default, const EMeshAttributeFlags Flags)
	{
		if (Map.find(AttributeName) == Map.end())
		{
			Map.emplace(AttributeName, TAttributeIndicesArray<AttributeType, ElementIDType>(NumberOfIndices, Default, Flags, NumElements));
		}
	}
	inline void UnregisterAttribute(const std::string& AttributeName)
	{
		Map.Remove(AttributeName);
	}

	/** Determines whether an attribute exists with the given name */
	inline bool HasAttribute(const std::string& AttributeName) const
	{
		return Map.Contains(AttributeName);
	}

	/** Get attribute array with the given name and index */
	inline TMeshAttributeArray<AttributeType, ElementIDType>& GetAttributes(const std::string& AttributeName, const int32 AttributeIndex = 0)
	{
		// @todo mesh description: should this handle non-existent attribute names and indices gracefully?
		return Map.at(AttributeName).GetArrayForIndex(AttributeIndex);
	}

	inline const TMeshAttributeArray<AttributeType, ElementIDType>& GetAttributes(const std::string& AttributeName, const int32 AttributeIndex = 0) const
	{
		// @todo mesh description: should this handle non-existent attribute names and indices gracefully?
		return Map.at(AttributeName).GetArrayForIndex(AttributeIndex);
	}

	
private:
	/** Number of elements for each attribute index */
	int32 NumElements;

	/** The actual container */
	MapType Map;
};

template <class T, class Tuple>
struct TTupleIndex;

template <class T, class... Types>
struct TTupleIndex<T, std::tuple<T, Types...>> {
	static const std::size_t Value = 0;
};

template <class T, class U, class... Types>
struct TTupleIndex<T, std::tuple<U, Types...>> {
	static const std::size_t Value = 1U + TTupleIndex<T, std::tuple<Types...>>::Value;
};

template <typename ElementIDType>
class TAttributesSet
{
public:
	template <typename AttributeType>
	void RegisterAttribute(const std::string& AttributeName, const int32 NumberOfIndices = 1, const AttributeType& Default = AttributeType(), const EMeshAttributeFlags Flags = EMeshAttributeFlags::None)
	{
		std::get<TTupleIndex<AttributeType, AttributeTypes>::Value>(Container).RegisterAttribute(AttributeName, NumberOfIndices, Default, Flags);
	}
	/** Unregister an attribute name with the given type */
	template <typename AttributeType>
	void UnregisterAttribute(const std::string& AttributeName)
	{
		std::get<TTupleIndex<AttributeType, AttributeTypes>::Value>(Container).UnregisterAttribute(AttributeName);
	}

	template <typename AttributeType>
	bool HasAttribute(const std::string& AttributeName) const
	{
		return std::get<TTupleIndex<AttributeType, AttributeTypes>::Value>(Container).HasAttribute(AttributeName);
	}

	template <typename AttributeType>
	TMeshAttributeArray<AttributeType, ElementIDType>& GetAttributes(const std::string& AttributeName, const int32 AttributeIndex = 0)
	{
		// @todo mesh description: should this handle non-existent attribute names and indices gracefully?
		return std::get<TTupleIndex<AttributeType, AttributeTypes>::Value>(Container).GetAttributes(AttributeName, AttributeIndex);
	}

	template <typename AttributeType>
	const TMeshAttributeArray<AttributeType, ElementIDType>& GetAttributes(const std::string& AttributeName, const int32 AttributeIndex = 0) const
	{
		// @todo mesh description: should this handle non-existent attribute names and indices gracefully?
		return std::get<TTupleIndex<AttributeType, AttributeTypes>::Value>(Container).GetAttributes(AttributeName, AttributeIndex);
	}

	void Insert(const ElementIDType ElementID)
	{
		//VisitTupleElements([ElementID](auto& AttributesMap) { AttributesMap.Insert(ElementID); }, Container);
	}

private:
	using ContainerType = 
	std::tuple
	<
		TAttributesMap<FVector4,	ElementIDType>,
		TAttributesMap<FVector,		ElementIDType>,
		TAttributesMap<FVector2D,	ElementIDType>,
		TAttributesMap<float,		ElementIDType>,
		TAttributesMap<int,			ElementIDType>,
		TAttributesMap<bool,		ElementIDType>,
		TAttributesMap<std::string, ElementIDType>
	>;

	ContainerType Container;
};

